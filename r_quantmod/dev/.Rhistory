rstudio <- "RStudio"
match <- grep(rstudio, args)
if (length(match) > 0) {
return(dirname(rstudioapi::getSourceEditorContext()$path))
} else {
match <- grep(file, args)
if (length(match) > 0) {
return(dirname(normalizePath(sub(file, "", args[match]))))
} else {
return(dirname(normalizePath(sys.frames()[[1]]$ofile)))
}
}
}
setwd(get_dir() )
rd <- setwd("/")
collect_data <- function() {
### Define path and other variables
xf <- paste(rd, "src/", sep = "")
qm_src <- "yahoo"
yx <- year(now())
dfrom <- paste(yx,"-01-01",sep = "")
tryCatch({
symbol_list <- fetch(res, n = -1)
### Define data to collect
symbol <- symbol_list[i,5]
dataframe <- as.data.frame(getSymbols(symbol, src = qm_src, from = dfrom, env = NULL))
### Set columns name
colnames(dataframe)[1] <- "open"
colnames(dataframe)[2] <- "high"
colnames(dataframe)[3] <- "low"
colnames(dataframe)[4] <- "close"
colnames(dataframe)[5] <- "volume"
colnames(dataframe)[6] <- "adjusted"
### Export content to CSV ###
fn <- paste(symbol,".csv", sep = "")
f <- paste(xf,fn, sep = "")
write.csv(dataframe, file = f)
}, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
}
collect_data()
# Copyright (c) 2018-present, Taatu Ltd.
#
# This source code is licensed under the MIT license found in the
# LICENSE file in the root directory of this source tree.
library(base)
library(rstudioapi)
get_dir <- function() {
args <- commandArgs(trailingOnly = FALSE)
file <- "--file="
rstudio <- "RStudio"
match <- grep(rstudio, args)
if (length(match) > 0) {
return(dirname(rstudioapi::getSourceEditorContext()$path))
} else {
match <- grep(file, args)
if (length(match) > 0) {
return(dirname(normalizePath(sub(file, "", args[match]))))
} else {
return(dirname(normalizePath(sys.frames()[[1]]$ofile)))
}
}
}
setwd(get_dir() )
rd <- setwd("/")
collect_data <- function() {
### Define path and other variables
xf <- paste(rd, "src/", sep = "")
qm_src <- "yahoo"
yx <- year(now())
dfrom <- paste(yx,"-01-01",sep = "")
tryCatch({
symbol_list <- fetch(res, n = -1)
### Define data to collect
symbol <- symbol_list[i,5]
dataframe <- as.data.frame(getSymbols(symbol, src = qm_src, from = dfrom, env = NULL))
### Set columns name
colnames(dataframe)[1] <- "open"
colnames(dataframe)[2] <- "high"
colnames(dataframe)[3] <- "low"
colnames(dataframe)[4] <- "close"
colnames(dataframe)[5] <- "volume"
colnames(dataframe)[6] <- "adjusted"
### Export content to CSV ###
fn <- paste(symbol,".csv", sep = "")
f <- paste(xf,fn, sep = "")
write.csv(dataframe, file = f)
}, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
}
inst_ini_package <- function(){
list.of.packages <- c("lubridate","quantmod", "tidyquant", "DBI", "RMySQL","binhf","tseries","forecast")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
library("quantmod")
library("lubridate")
library("DBI")
library("RMySQL")
library("binhf")
library("tseries")
library("forecast")
}
inst_ini_package()
collect_data()
# Copyright (c) 2018-present, Taatu Ltd.
#
# This source code is licensed under the MIT license found in the
# LICENSE file in the root directory of this source tree.
library(base)
library(rstudioapi)
get_dir <- function() {
args <- commandArgs(trailingOnly = FALSE)
file <- "--file="
rstudio <- "RStudio"
match <- grep(rstudio, args)
if (length(match) > 0) {
return(dirname(rstudioapi::getSourceEditorContext()$path))
} else {
match <- grep(file, args)
if (length(match) > 0) {
return(dirname(normalizePath(sub(file, "", args[match]))))
} else {
return(dirname(normalizePath(sys.frames()[[1]]$ofile)))
}
}
}
setwd(get_dir() )
rd <- setwd("/")
dir.create(file.path(rd, "src"), showWarnings = FALSE)
collect_data <- function() {
### Define path and other variables
xf <- paste(rd, "src/", sep = "")
qm_src <- "yahoo"
yx <- year(now())
dfrom <- paste(yx,"-01-01",sep = "")
tryCatch({
symbol_list <- fetch(res, n = -1)
### Define data to collect
symbol <- "EURUSD=X"
dataframe <- as.data.frame(getSymbols(symbol, src = qm_src, from = dfrom, env = NULL))
### Set columns name
colnames(dataframe)[1] <- "open"
colnames(dataframe)[2] <- "high"
colnames(dataframe)[3] <- "low"
colnames(dataframe)[4] <- "close"
colnames(dataframe)[5] <- "volume"
colnames(dataframe)[6] <- "adjusted"
### Export content to CSV ###
fn <- paste(symbol,".csv", sep = "")
f <- paste(xf,fn, sep = "")
write.csv(dataframe, file = f)
}, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
}
inst_ini_package <- function(){
list.of.packages <- c("lubridate","quantmod", "tidyquant", "DBI", "RMySQL","binhf","tseries","forecast")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
library("quantmod")
library("lubridate")
library("DBI")
library("RMySQL")
library("binhf")
library("tseries")
library("forecast")
}
inst_ini_package()
collect_data()
getwd()
rd <- setwd(get_dir() )
get_dir()
rd <- setwd(get_dir() )
# Copyright (c) 2018-present, Taatu Ltd.
#
# This source code is licensed under the MIT license found in the
# LICENSE file in the root directory of this source tree.
library(base)
library(rstudioapi)
get_dir <- function() {
args <- commandArgs(trailingOnly = FALSE)
file <- "--file="
rstudio <- "RStudio"
match <- grep(rstudio, args)
if (length(match) > 0) {
return(dirname(rstudioapi::getSourceEditorContext()$path))
} else {
match <- grep(file, args)
if (length(match) > 0) {
return(dirname(normalizePath(sub(file, "", args[match]))))
} else {
return(dirname(normalizePath(sys.frames()[[1]]$ofile)))
}
}
}
rd <- setwd(get_dir() )
dir.create(file.path(rd, "src"), showWarnings = FALSE)
collect_data <- function() {
### Define path and other variables
xf <- paste(rd, "src/", sep = "")
qm_src <- "yahoo"
yx <- year(now())
dfrom <- paste(yx,"-01-01",sep = "")
tryCatch({
symbol_list <- fetch(res, n = -1)
### Define data to collect
symbol <- "EURUSD=X"
dataframe <- as.data.frame(getSymbols(symbol, src = qm_src, from = dfrom, env = NULL))
### Set columns name
colnames(dataframe)[1] <- "open"
colnames(dataframe)[2] <- "high"
colnames(dataframe)[3] <- "low"
colnames(dataframe)[4] <- "close"
colnames(dataframe)[5] <- "volume"
colnames(dataframe)[6] <- "adjusted"
### Export content to CSV ###
fn <- paste(symbol,".csv", sep = "")
f <- paste(xf,fn, sep = "")
write.csv(dataframe, file = f)
}, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
}
inst_ini_package <- function(){
list.of.packages <- c("lubridate","quantmod", "tidyquant", "DBI", "RMySQL","binhf","tseries","forecast")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
library("quantmod")
library("lubridate")
library("DBI")
library("RMySQL")
library("binhf")
library("tseries")
library("forecast")
}
inst_ini_package()
# Copyright (c) 2018-present, Taatu Ltd.
#
# This source code is licensed under the MIT license found in the
# LICENSE file in the root directory of this source tree.
library(base)
library(rstudioapi)
get_dir <- function() {
args <- commandArgs(trailingOnly = FALSE)
file <- "--file="
rstudio <- "RStudio"
match <- grep(rstudio, args)
if (length(match) > 0) {
return(dirname(rstudioapi::getSourceEditorContext()$path))
} else {
match <- grep(file, args)
if (length(match) > 0) {
return(dirname(normalizePath(sub(file, "", args[match]))))
} else {
return(dirname(normalizePath(sys.frames()[[1]]$ofile)))
}
}
}
rd <- setwd(get_dir() )
dir.create(file.path(rd, "src"), showWarnings = FALSE)
collect_data <- function() {
### Define path and other variables
xf <- paste(rd, "src/", sep = "")
qm_src <- "yahoo"
yx <- year(now())
dfrom <- paste(yx,"-01-01",sep = "")
tryCatch({
symbol_list <- fetch(res, n = -1)
### Define data to collect
symbol <- "EURUSD=X"
dataframe <- as.data.frame(getSymbols(symbol, src = qm_src, from = dfrom, env = NULL))
### Set columns name
colnames(dataframe)[1] <- "open"
colnames(dataframe)[2] <- "high"
colnames(dataframe)[3] <- "low"
colnames(dataframe)[4] <- "close"
colnames(dataframe)[5] <- "volume"
colnames(dataframe)[6] <- "adjusted"
### Export content to CSV ###
fn <- paste(symbol,".csv", sep = "")
f <- paste(xf,fn, sep = "")
write.csv(dataframe, file = f)
}, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
}
inst_ini_package <- function(){
list.of.packages <- c("lubridate","quantmod", "tidyquant", "DBI", "RMySQL","binhf","tseries","forecast")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
library("quantmod")
library("lubridate")
library("tseries")
}
inst_ini_package()
# Copyright (c) 2018-present, Taatu Ltd.
#
# This source code is licensed under the MIT license found in the
# LICENSE file in the root directory of this source tree.
library(base)
library(rstudioapi)
get_dir <- function() {
args <- commandArgs(trailingOnly = FALSE)
file <- "--file="
rstudio <- "RStudio"
match <- grep(rstudio, args)
if (length(match) > 0) {
return(dirname(rstudioapi::getSourceEditorContext()$path))
} else {
match <- grep(file, args)
if (length(match) > 0) {
return(dirname(normalizePath(sub(file, "", args[match]))))
} else {
return(dirname(normalizePath(sys.frames()[[1]]$ofile)))
}
}
}
rd <- setwd(get_dir() )
dir.create(file.path(rd, "src"), showWarnings = FALSE)
collect_data <- function() {
### Define path and other variables
xf <- paste(rd, "src/", sep = "")
qm_src <- "yahoo"
yx <- year(now())
dfrom <- paste(yx,"-01-01",sep = "")
tryCatch({
symbol_list <- fetch(res, n = -1)
### Define data to collect
symbol <- "EURUSD=X"
dataframe <- as.data.frame(getSymbols(symbol, src = qm_src, from = dfrom, env = NULL))
### Set columns name
colnames(dataframe)[1] <- "open"
colnames(dataframe)[2] <- "high"
colnames(dataframe)[3] <- "low"
colnames(dataframe)[4] <- "close"
colnames(dataframe)[5] <- "volume"
colnames(dataframe)[6] <- "adjusted"
### Export content to CSV ###
fn <- paste(symbol,".csv", sep = "")
f <- paste(xf,fn, sep = "")
write.csv(dataframe, file = f)
}, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
}
inst_ini_package <- function(){
list.of.packages <- c("lubridate","quantmod")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
library("quantmod")
library("lubridate")
}
inst_ini_package()
collect_data()
# Copyright (c) 2018-present, Taatu Ltd.
#
# This source code is licensed under the MIT license found in the
# LICENSE file in the root directory of this source tree.
library(base)
library(rstudioapi)
get_dir <- function() {
args <- commandArgs(trailingOnly = FALSE)
file <- "--file="
rstudio <- "RStudio"
match <- grep(rstudio, args)
if (length(match) > 0) {
return(dirname(rstudioapi::getSourceEditorContext()$path))
} else {
match <- grep(file, args)
if (length(match) > 0) {
return(dirname(normalizePath(sub(file, "", args[match]))))
} else {
return(dirname(normalizePath(sys.frames()[[1]]$ofile)))
}
}
}
rd <- setwd(get_dir() )
dir.create(file.path(rd, "src"), showWarnings = FALSE)
collect_data <- function() {
### Define path and other variables
xf <- paste(rd, "src/", sep = "")
qm_src <- "yahoo"
yx <- year(now())
dfrom <- paste(yx,"-01-01",sep = "")
tryCatch({
### Define data to collect
symbol <- "EURUSD=X"
dataframe <- as.data.frame(getSymbols(symbol, src = qm_src, from = dfrom, env = NULL))
### Set columns name
colnames(dataframe)[1] <- "open"
colnames(dataframe)[2] <- "high"
colnames(dataframe)[3] <- "low"
colnames(dataframe)[4] <- "close"
colnames(dataframe)[5] <- "volume"
colnames(dataframe)[6] <- "adjusted"
### Export content to CSV ###
fn <- paste(symbol,".csv", sep = "")
f <- paste(xf,fn, sep = "")
write.csv(dataframe, file = f)
}, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
}
inst_ini_package <- function(){
list.of.packages <- c("lubridate","quantmod")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
library("quantmod")
library("lubridate")
}
inst_ini_package()
collect_data()
# Copyright (c) 2018-present, Taatu Ltd.
#
# This source code is licensed under the MIT license found in the
# LICENSE file in the root directory of this source tree.
library(base)
library(rstudioapi)
get_dir <- function() {
args <- commandArgs(trailingOnly = FALSE)
file <- "--file="
rstudio <- "RStudio"
match <- grep(rstudio, args)
if (length(match) > 0) {
return(dirname(rstudioapi::getSourceEditorContext()$path))
} else {
match <- grep(file, args)
if (length(match) > 0) {
return(dirname(normalizePath(sub(file, "", args[match]))))
} else {
return(dirname(normalizePath(sys.frames()[[1]]$ofile)))
}
}
}
rd <- setwd(get_dir() )
dir.create(file.path(rd, "src"), showWarnings = FALSE)
collect_data <- function() {
### Define path and other variables
xf <- paste(rd, "/src/", sep = "")
qm_src <- "yahoo"
yx <- year(now())
dfrom <- paste(yx,"-01-01",sep = "")
tryCatch({
### Define data to collect
symbol <- "EURUSD=X"
dataframe <- as.data.frame(getSymbols(symbol, src = qm_src, from = dfrom, env = NULL))
### Set columns name
colnames(dataframe)[1] <- "open"
colnames(dataframe)[2] <- "high"
colnames(dataframe)[3] <- "low"
colnames(dataframe)[4] <- "close"
colnames(dataframe)[5] <- "volume"
colnames(dataframe)[6] <- "adjusted"
### Export content to CSV ###
fn <- paste(symbol,".csv", sep = "")
f <- paste(xf,fn, sep = "")
write.csv(dataframe, file = f)
}, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
}
inst_ini_package <- function(){
list.of.packages <- c("lubridate","quantmod")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
library("quantmod")
library("lubridate")
}
inst_ini_package()
collect_data()
# Copyright (c) 2018-present, Taatu Ltd.
#
# This source code is licensed under the MIT license found in the
# LICENSE file in the root directory of this source tree.
library(base)
library(rstudioapi)
get_dir <- function() {
args <- commandArgs(trailingOnly = FALSE)
file <- "--file="
rstudio <- "RStudio"
match <- grep(rstudio, args)
if (length(match) > 0) {
return(dirname(rstudioapi::getSourceEditorContext()$path))
} else {
match <- grep(file, args)
if (length(match) > 0) {
return(dirname(normalizePath(sub(file, "", args[match]))))
} else {
return(dirname(normalizePath(sys.frames()[[1]]$ofile)))
}
}
}
rd <- setwd(get_dir() )
dir.create(file.path(rd, "src"), showWarnings = FALSE)
collect_data <- function() {
### Define path and other variables
xf <- paste(rd, "/src/", sep = "")
qm_src <- "yahoo"
yx <- year(now())
dfrom <- paste(yx,"-01-01",sep = "")
tryCatch({
### Define data to collect
symbol <- "EURUSD=X"
dataframe <- as.data.frame(getSymbols(symbol, src = qm_src, from = dfrom, env = NULL))
### Set columns name
colnames(dataframe)[1] <- "open"
colnames(dataframe)[2] <- "high"
colnames(dataframe)[3] <- "low"
colnames(dataframe)[4] <- "close"
colnames(dataframe)[5] <- "volume"
colnames(dataframe)[6] <- "adjusted"
### Export content to CSV ###
fn <- paste(symbol,".csv", sep = "")
f <- paste(xf,fn, sep = "")
write.csv(dataframe, file = f)
}, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
}
inst_ini_package <- function(){
list.of.packages <- c("lubridate","quantmod")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
library("quantmod")
library("lubridate")
}
inst_ini_package()
collect_data()
